/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * February 21, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "scanAgentList_test.hpp"
#include "TrampolineOsDataCache.hpp"
#include "scanAgentList.hpp"
#include "shared_modules/utils/mocks/chainOfResponsabilityMock.h"

using testing::_;

const std::string EXPECTED_QUERY_PACKAGE {"agent 001 package get "};
const std::string EXPECTED_QUERY_OS {"agent 001 osinfo get "};
const std::string EXPECTED_QUERY_MANAGER {"agent 0 package get "};
const std::string PACKAGES_RESPONSE {
    R"(ok [{"architecture":"x86_64","checksum":"qwerty","description":"Web Browser","format":"deb","groups":"","install_time":"02/22/2024 00:00:00","item_id":"ytrewq","location":"","multiarch":"","name":"Firefox","priority":"","scan_time":"02/21/2024 00:00:00","size":0,"source":"","vendor":"canonical","version":"122.0.1"},{"architecture":"x86_64","checksum":"asdfgh","description":"Text editor","format":"deb","groups":"","install_time":"02/22/2024 00:00:00","item_id":"hgfdsa","location":"","multiarch":"","name":"Neovim","priority":"","scan_time":"02/21/2024 00:00:00","size":0,"source":"","vendor":"canonical","version":"0.9.5"}])"};

const std::string OS_RESPONSE {
    R"(ok [{"checksum":"qwerty","hostname":"osdata_hostname","os_build":"osdata_build","os_codename":"upstream","os_display_version":"osdata_displayVersion","os_major":"osdata_majorVersion","os_minor":"osdata_minorVersion","os_name":"osdata_name","os_patch":"osdata_patch","os_platform":"osdata_platform","os_release":"osdata_release","os_version":"osdata_version","release":"osdata_release","scan_time":"02/21/2024 00:00:00","sysname":"osdata_sysName","version":"osdata_version"}])"};

const std::string RESPONSE_EMPTY {R"(ok )"};

TEST_F(ScanAgentListTest, SingleDeleteAndInsertTest)
{
    const std::vector EXPECTED_QUERIES {EXPECTED_QUERY_OS, EXPECTED_QUERY_PACKAGE};
    const std::vector RESPONSES {OS_RESPONSE, PACKAGES_RESPONSE};

    auto index = 0;

    m_socketServer->listen(
        [&](const int fd, const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader)
        {
            std::ignore = dataHeader;
            std::ignore = sizeHeader;

            std::string receivedMsg(data, size);
            EXPECT_STREQ(receivedMsg.c_str(), EXPECTED_QUERIES.at(index).c_str());

            m_socketServer->send(fd, RESPONSES.at(index).c_str(), RESPONSES.at(index).size());

            ++index;
        });

    Os osData {.hostName = "osdata_hostname",
               .architecture = "osdata_architecture",
               .name = "osdata_name",
               .codeName = "upstream",
               .majorVersion = "osdata_majorVersion",
               .minorVersion = "osdata_minorVersion",
               .patch = "osdata_patch",
               .build = "osdata_build",
               .platform = "osdata_platform",
               .version = "osdata_version",
               .release = "osdata_release",
               .displayVersion = "osdata_displayVersion",
               .sysName = "osdata_sysName",
               .kernelVersion = "osdata_kernelVersion",
               .kernelRelease = "osdata_kernelRelease"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, getOsData(testing::_)).WillRepeatedly(testing::Return(osData));
    EXPECT_CALL(*spOsDataCacheMock, setOsData(_, _)).Times(1);

    auto spPackageInsertOrchestrationMock =
        std::make_shared<MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>();

    auto spOsOrchestrationMock =
        std::make_shared<MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>();

    // Called twice because the server socket response has two packages.
    EXPECT_CALL(*spPackageInsertOrchestrationMock, handleRequest(testing::_)).Times(2);

    EXPECT_CALL(*spOsOrchestrationMock, handleRequest(testing::_)).Times(1);

    auto scanAgentList =
        std::make_shared<TScanAgentList<TScanContext<TrampolineOsDataCache>,
                                        MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>>(
            spPackageInsertOrchestrationMock, spOsOrchestrationMock);

    nlohmann::json jsonData = nlohmann::json::parse(
        R"({"agent_info":  {"agent_id":"001",  "agent_version":"4.8.0",  "agent_name":"test_agent_name",  "agent_ip":"10.0.0.1",  "node_name":"node01"},  "action":"upgradeAgentDB"})");

    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*, const nlohmann::json*>
        data = &jsonData;

    auto contextData = std::make_shared<TScanContext<TrampolineOsDataCache>>(data);
    contextData->m_agents.push_back({"001", "test_agent_name", "4.8.0", "192.168.0.1", "node01"});

    scanAgentList->handleRequest(contextData);
}

TEST_F(ScanAgentListTest, EmptyPackagesWDBResponseTest)
{
    const std::vector EXPECTED_QUERIES {EXPECTED_QUERY_OS, EXPECTED_QUERY_PACKAGE};
    const std::vector RESPONSES {OS_RESPONSE, RESPONSE_EMPTY};

    auto index = 0;

    m_socketServer->listen(
        [&](const int fd, const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader)
        {
            std::ignore = dataHeader;
            std::ignore = sizeHeader;

            std::string receivedMsg(data, size);
            EXPECT_STREQ(receivedMsg.c_str(), EXPECTED_QUERIES.at(index).c_str());

            m_socketServer->send(fd, RESPONSES.at(index).c_str(), RESPONSES.at(index).size());

            ++index;
        });

    Os osData {.hostName = "osdata_hostname",
               .architecture = "osdata_architecture",
               .name = "osdata_name",
               .codeName = "upstream",
               .majorVersion = "osdata_majorVersion",
               .minorVersion = "osdata_minorVersion",
               .patch = "osdata_patch",
               .build = "osdata_build",
               .platform = "osdata_platform",
               .version = "osdata_version",
               .release = "osdata_release",
               .displayVersion = "osdata_displayVersion",
               .sysName = "osdata_sysName",
               .kernelVersion = "osdata_kernelVersion",
               .kernelRelease = "osdata_kernelRelease"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, getOsData(testing::_)).WillRepeatedly(testing::Return(osData));
    EXPECT_CALL(*spOsDataCacheMock, setOsData(_, _)).Times(1);

    auto spPackageInsertOrchestrationMock =
        std::make_shared<MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>();

    auto spOsOrchestrationMock =
        std::make_shared<MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>();

    // Called twice because the server socket response has two packages.
    EXPECT_CALL(*spPackageInsertOrchestrationMock, handleRequest(testing::_)).Times(0);

    EXPECT_CALL(*spOsOrchestrationMock, handleRequest(testing::_)).Times(1);

    auto scanAgentList =
        std::make_shared<TScanAgentList<TScanContext<TrampolineOsDataCache>,
                                        MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>>(
            spPackageInsertOrchestrationMock, spOsOrchestrationMock);

    nlohmann::json jsonData = nlohmann::json::parse(
        R"({"agent_info":  {"agent_id":"001",  "agent_version":"4.8.0",  "agent_name":"test_agent_name",  "agent_ip":"10.0.0.1",  "node_name":"node01"},  "action":"upgradeAgentDB"})");

    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*, const nlohmann::json*>
        data = &jsonData;

    auto contextData = std::make_shared<TScanContext<TrampolineOsDataCache>>(data);
    contextData->m_agents.push_back({"001", "test_agent_name", "4.8.0", "192.168.0.1", "node01"});

    scanAgentList->handleRequest(contextData);
}

TEST_F(ScanAgentListTest, DISABLED_InsertAllTestNotSyncedResponse)
{
    m_socketServer->listen(
        [&](const int fd, const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader)
        {
            std::ignore = dataHeader;
            std::ignore = sizeHeader;

            std::string receivedMsg(data, size);
            EXPECT_STREQ(receivedMsg.c_str(), EXPECTED_QUERY_MANAGER.c_str());

            m_socketServer->send(fd, PACKAGES_RESPONSE.c_str(), PACKAGES_RESPONSE.size());
        });

    Os osData {.hostName = "osdata_hostname",
               .architecture = "osdata_architecture",
               .name = "osdata_name",
               .codeName = "upstream",
               .majorVersion = "osdata_majorVersion",
               .minorVersion = "osdata_minorVersion",
               .patch = "osdata_patch",
               .build = "osdata_build",
               .platform = "osdata_platform",
               .version = "osdata_version",
               .release = "osdata_release",
               .displayVersion = "osdata_displayVersion",
               .sysName = "osdata_sysName",
               .kernelVersion = "osdata_kernelVersion",
               .kernelRelease = "osdata_kernelRelease"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, getOsData(testing::_)).WillRepeatedly(testing::Return(osData));

    auto spOsOrchestrationMock =
        std::make_shared<MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>();

    auto spPackageInsertOrchestrationMock =
        std::make_shared<MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>();

    // Called twice because the server socket response has two packages.
    EXPECT_CALL(*spPackageInsertOrchestrationMock, handleRequest(testing::_)).Times(0);

    auto scanAgentList =
        std::make_shared<TScanAgentList<TScanContext<TrampolineOsDataCache>,
                                        MockAbstractHandler<std::shared_ptr<TScanContext<TrampolineOsDataCache>>>>>(
            spOsOrchestrationMock, spPackageInsertOrchestrationMock);

    nlohmann::json jsonData = nlohmann::json::parse(R"([{"status":"NOT_SYNCED"}])");

    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*, const nlohmann::json*>
        data = &jsonData;

    auto contextData = std::make_shared<TScanContext<TrampolineOsDataCache>>(data);

    scanAgentList->handleRequest(contextData);
}
